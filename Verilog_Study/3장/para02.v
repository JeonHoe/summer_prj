// 데이터 형

// 논리값 집합
// Verilog는 실제 하드웨어의 기능을 모델로 한 4개의 논리값과 8개의 신호 강도를 지원한다.

// 4개의 논리값
//     논리값 수준      |    하드웨어 회로의 상태
//          0                논리적 0, 거짓 상태 
//          1                 논리적 1, 참 상태
//          x                알 수 없는 논리 값
//          z             하이 임피던스, 플로팅 상태

// 논리값과 더불어 신호 강도는 디지털 회로에서 서로 다른 강도를 갖는 신호의 충돌을 해결하는데 종종 쓰인다.

// 신호 강도

/* 신호 강도     |         형         |          정도
    supply           흐름(driving)          가장 강도가 강함
    strong           흐름(driving)
     pull            흐름(driving)
    large            저장(storage)
     weak            흐름(driving)
    medium           저장(storage)
    small            저장(storage)
    highz            하이 임피던스           가장 강도가 약함*/

// 만약 다른 강도의 두 신호가 동일한 와이어(wire)에 흐르면, 더 강한 강도의 신호가 우세하다.
// 예를 들어 stornge1과 weak0이 만나면 결과는 strong1이다.
// 하지만 마약 신호강도가 같은 신호가 만나면 결과는 알 수 없다. 따라서 결과는 x이다.

// 넷(Nets)

// 넷은 하드웨어 요소 사이에 연결을 나타낸다.
// 넷은 실제 회로에서처럼, 연결되어 있는 장치의 출력으로 유도되는 연속적인 값을 갖는다.
// 넷은 키워드 wire에 의해 정의된다.
// 넷의 크기를 정하는 벡터를 지정하지 않으면 기본적으로 1비트 넷으로 선언된다.
// 와이어와 넷은 종종 서로 같은 뜻으로 사용되며 넷의 기본값은 z이다(trireg 넷은 기본값이 x).
// 넷은 그것에 유도된 출력값을 갖게 되고, 만약 유도되는 값이 없다면, z값을 갖게 된다.

wire a = 1'b0; // 넷 a는 논리값으로 0으로 선언

// 넷은 키워드가 아닌 wire, wand, wor, tri, triand 등의 집합을 나타낸다.
// 다만 대부분 wire로 선언을 한다.

// 레지스터

// 레지스터는 데이터를 저장할 수 있다.
// 레지스터는 다른 논리값이 들어오기 전까지는 그 값을 유지할 수 있다.
// 중요한 것은 Verilog에서의 레지스터와 플립플롭과 같은 하드웨어 레지스터를 혼동해선 안된다는 것이다.
// Verilog에서의 레지스터는 그저 값을 저장할 수 있는 변수를 의미한다.
// 신호의 유도를 필요로하는 넷과는 달리 레지스터는 신호의 유도를 필요로 하지 않는다.
// Verilog에서의 레지스터는 하드웨어 레지스터와 달리 클록을 필요로 하지 않는다.
// 레지스터의 논리값은 시뮬레이션시 레지스터에 새로운 값을 대입함으써 변경할 수 있다.
// 레지스터 데이터형은 키워드 reg에 의해 정의된다.

reg reset; // 값을 가질 수 잇는 변수 reset 정의.
initial
begin
    reset = 1'b1; // 디지털 회로에서 reset을 1로 초기화 한다.
    #100 reset = 1'b0; // 100 단위시간이 지난 뒤 reset값을 바꾼다.
end

// 레지스터는 또한 부호 있는 변수도 선언될 수 있다.
// 그러한 레지스터는 부호 있는 산술에 사용된다.

reg signed [63:0] m; // 64비트 부호 있는 값
integer i;           // 32비트 부호 있는 값

// 벡터

// 넷과 reg 데이터형은 벡터(여러 비트 폭을 가진)로 선언될 수 있다.
// 만약 폭이 선언되어 있지 않으면 기본값은 스칼라(1비트)이다.

wire a; // 스칼라 넷 변수. 기본값.
wire [7:0] bus; // 8비트 bus.
wire [31:0] busA, busB, busC; // 32비트의 폭을 가진 3개의 bus들.
reg clock; // 스칼라 레지스터. 기본값.
reg [0:40] virtural_addr; // 41비트 폭을 가진 벡터 레지스터.

// 벡터 부분 선택

// 아래의 벡터 선언처럼, 주소 비트 또는 벡터의 일부분을 나타낼 수 있다.

busA[7] // 벡터 busA의 7번 비트.
bus[2:0] // 벡터 bus의 3개의 하위 비트,
         // significant 비트는 범위지정에서 항상 왼쪽에 와야 되기 때문에
         // bus[0:2]로 사용하는 것은 불법이다.
virtural_addr[0:1] // virtural_addr의 2개의 상위 비트.

// 가변 벡터 부분 선택

// Verilog는 벡터의 가변 부분 선택도 제공한다.
// 이는 다양한 벡터의 일부분을 선택하기 위해 루프를 집어넣는 부분 선택을 할 수 있다.

/*[<시작 비트>+:폭] -> 시작비트부터 부분 선택 증가
  [<시작 비트>-:폭] -> 시작비트부터 부분 선택 감소*/

// 부분 선택의 시작 비트는 다양하다.
// 그러나 폭은 일정해야 한다.

reg [255:0] data1; // 리틀-에디언(Little endian) 표기법
reg [0:255] data2; // 빅-에디언(Big endian) 표기법
reg [7:0] byte;

// 가변 부분을 선택 사용, 각각은 부분들을 선택할 수 있다
byte = data1[31-:8]; // starting bit = 31, width = 8 => data[31:24]
byte = data1[24+:8]; // starting bit = 24, width = 8 => data[31:24]
byte = data2[31-:8]; // starting bit = 31, width = 8 => data[24:31]
byte = data2[24+:8]; // starting bit = 24, width = 8 => data[24:31]

// 시작 비트는 변할 수 있다. 폭은 상수값을 가진다.
// 그러므로, 루프문을 이용하여 벡터의 모든 바이트들을
// 선택하기 위하여 가변 부분 선택을 할 수 있다.
for (j = 0; j<=31; j=j+1)
    byte = data1[(j*8)+:8]; // 순서는 [7:0], [15:8], ... , [255:248]

// 벡터의 부분을 초기화할 수 있다.
data1[(byteNum*8)+:8] = 8'b0; // 만약 byteNum = 1, 8비트 [15:8]를 클리어.

// 정수, 실수, 시간 레지스터 데이터형

// Verilog는 정수, 실수, 시간 레지스터 데이터형을 지원한다.

// 정수

// 정수는 양을 다루기 위한 일반적인 범용 레지스터 데이터형이다.
// 정수는 키워드 interger에 의해 선언된다.
// 범용 변수로 reg를 사용해도 되나 카운트 같은 목적을 위해서는 정수를 사용하는 것이 더 좋다.
// 정수의 기본 폭은 지정된 호스트 기계의 워드 크기와 같다. 적어도 32비트.
// reg로 선언된 레지스터는 음수 불가능 수로 저장되지만, interger는 음수 가능 수로 저장된다.

integer counter; // counter로 사용되는 범용 변수
initial
    counter = -1; // counter에 음수 1를 저장.

// 실수

// 실수는 상수이고, 실수 레지스터 데이터형은 키워드 real에 의해 선언된다.
// 실수는 십진표기법(예 : 3.14) 또는 과학적 표기법(예 : 3*10^6을 뜻하는 3e6)로 나타낼 수 있다.
// 실수는 벡터를 가질 수 없고, 기본값은 0이다.
// 실수가 정수로 대입될 때, 실수는 가장 가까운 정수로 변환된다.

real delta; // delta라는 실수 정의
initial
begin
    delta = 4e10; // delta에 과학적 표기법으로 대입
    delta = 2.13; // delta에 2.13을 대입.
end
integer = i;
initial
    i = delta; // i는 2값을 갖는다(2.13 변환값).

// 시간

// Verilog 시뮬레이션은 시뮬레이션 시간(simulation time)을 고려하면서 동작한다.
// 시뮬레이션 시간을 저장하기 위해서 Verilog는 시간 레지스터 데이터형을 사용한다.
// 시간값은 키워드 time에 의해서 선언된다.

time save_sim_time; // 시간 변수 save_sim_time을 정의.
initial
    save_sim_time = $time; // 현재 시뮬레이션 시간을 저장.

// 시뮬레이션 초(simulation second)로 시뮬레이션 시간을 잰다.
// 이 단위는 실제 시간과 마찬가지로 s로 표시된다.
// 그러나 디지털 회로에서의 실제 시간과 시뮬레이션 시간의 관계는 사용자에게 위임한다.

// 배열

// Verilog는 reg, integer, time, real, realtime 그리고 벡터 레지스터 데이터형의 배열을 제공한다.
// 다차원 배열은 어떠한 차원으로도 선언된다.
// 넷의 배열 또한 생성된 인스턴스의 연결 포트에 사용될 수 있다.
// 배열의 각 요소는 스칼라 혹은 벡터로 써 같은 종류로 사용된다.
// 배열은 <배열 이름> [<서브 스크립트>] 형태로 쓰여 진다.

integer count [0:7]; // 8 count 변수의 배열.
reg bool [31:0]; // 32 1비트 bool 레지스터 변수의 배열.
time chk_point [1:100]; // 100 time chk_point 변수의 배열.
reg [4:0] port_id [0:7]; // 8 4 비트 port_id 레지스터 변수 배열.
integer matrix [4:0][0:255]; // 정수형 이차원 배열.
reg [63:0] array_4d [15:0][7:0][7:0][255:0]; // 사차원 배열.
wire [7:0] w_array2 [5:0]; // 8 비트 벡터 와이어 배열 선언.
wire w_array1 [7:0][5:0]; // 싱글 비트 벡터 와이어 2차원 배열 선언.

count[5] = 0; // count 변수 배열의 5번째 원소 리셋.
chk_point[100] = 0; //check point 값이 100번째 리셋
port_id[3] = 0; // port_id 배열의 세 번째 원소 리셋. 5 비트 값이다.

matrix[1][0] = 33559; // [1][0] 인덱스의 원소 값을 33559로 셋.
array_4d[0][0][0][0][15:0] = 0; // [0][0][0][0] 색인에 의해 접근되는 레지스터의 15:0 비트들 클리어.

// port_id = 0; // 불법 문법 -> 전체 배열 쓰기 시도
// matrix[1] = 0; // 불법 문법 -> [1][0], [1][1],...,[1][254], [1][255] 쓰기 시도

// 메모리

// 

