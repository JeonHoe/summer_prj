// 데이터 형

// 논리값 집합
// Verilog는 실제 하드웨어의 기능을 모델로 한 4개의 논리값과 8개의 신호 강도를 지원한다.

// 4개의 논리값
//     논리값 수준      |    하드웨어 회로의 상태
//          0                논리적 0, 거짓 상태 
//          1                 논리적 1, 참 상태
//          x                알 수 없는 논리 값
//          z             하이 임피던스, 플로팅 상태

// 논리값과 더불어 신호 강도는 디지털 회로에서 서로 다른 강도를 갖는 신호의 충돌을 해결하는데 종종 쓰인다.

// 신호 강도

/* 신호 강도     |         형         |          정도
    supply           흐름(driving)          가장 강도가 강함
    strong           흐름(driving)
     pull            흐름(driving)
    large            저장(storage)
     weak            흐름(driving)
    medium           저장(storage)
    small            저장(storage)
    highz            하이 임피던스           가장 강도가 약함*/

// 만약 다른 강도의 두 신호가 동일한 와이어(wire)에 흐르면, 더 강한 강도의 신호가 우세하다.
// 예를 들어 stornge1과 weak0이 만나면 결과는 strong1이다.
// 하지만 마약 신호강도가 같은 신호가 만나면 결과는 알 수 없다. 따라서 결과는 x이다.

// 넷(Nets)

// 넷은 하드웨어 요소 사이에 연결을 나타낸다.
// 넷은 실제 회로에서처럼, 연결되어 있는 장치의 출력으로 유도되는 연속적인 값을 갖는다.
// 넷은 키워드 wire에 의해 정의된다.
// 넷의 크기를 정하는 벡터를 지정하지 않으면 기본적으로 1비트 넷으로 선언된다.
// 와이어와 넷은 종종 서로 같은 뜻으로 사용되며 넷의 기본값은 z이다(trireg 넷은 기본값이 x).
// 넷은 그것에 유도된 출력값을 갖게 되고, 만약 유도되는 값이 없다면, z값을 갖게 된다.

wire a = 1b'0 // 넷 a는 논리값으로 0으로 선언

// 레지스터

// 레지스터는 데이터를 저장할 수 있다.
// 레지스터는 다른 논리값이 들어오기 전까지는 그 값을 유지할 수 있다.
// 중요한 것은 Verilog에서의 레지스터와 플립플롭과 같은 하드웨어 레지스터를 혼동해선 안된다는 것이다.
// Verilog에서의 레지스터는 그저 값을 저장할 수 있는 변수를 의미한다.
// 신호의 유도를 필요로하는 넷과는 달리 레지스터는 신호의 유도를 필요로 하지 않는다.
// Verilog에서의 레지스터는 하드웨어 레지스터와 달리 클록을 필요로 하지 않는다.
// 레지스터의 논리값은 시뮬레이션시 레지스터에 새로운 값을 대입함으써 변경할 수 있다.
// 레지스터 데이터형은 키워드 reg에 의해 정의된다.

reg reset; // 값을 가질 수 잇는 변수 reset 정의.
initial
begin
    reset = 1'b1 // 디지털 회로에서 reset을 1로 초기화 한다.
    #100 reset = 1'b0; // 100 단위시간이 지난 뒤 reset값을 바꾼다.
end

// 레지스터는 또한 부호 있는 변수도 선언될 수 있다.
// 그러한 레지스터는 부호 있는 산술에 사용된다.

reg signed [63:0] m; // 64비트 부호 있는 값
integer i;           // 32비트 부호 있는 값

// 벡터

// 넷과 reg 데이터형은 벡터(여러 비트 폭을 가진)로 선언될 수 있다.
// 만약 폭이 선언되어 있지 않으면 기본값은 스칼라(1비트)이다.

wire a; // 스칼라 넷 변수. 기본값.
wire [7:0] bus; // 8비트 bus.
wire [31:0] busA, busB, busC; // 32비트의 폭을 가진 3개의 bus들.
reg clock; // 스칼라 레지스터. 기본값.
reg [0:40] virtural_addr; // 41비트 폭을 가진 벡터 레지스터.

// 벡터 부분 선택

// 아래의 벡터 선언처럼, 주소 비트 또는 벡터의 일부분을 나타낼 수 있다.

busA[7] // 벡터 busA의 7번 비트.
bus[2:0] // 벡터 bus의 3개의 하위 비트,
         // significant 비트는 범위지정에서 항상 왼쪽에 와야 되기 때문에
         // bus[0:2]로 사용하는 것은 불법이다.
virtural_addr[0:1] // virtural_addr의 2개의 상위 비트.

// 가변 벡터 부분 선택

// Verilog는 벡터의 가변 부분 선택도 제공한다.
// 이는 다양한 벡터의 일부분을 선택하기 위해 루프를 집어넣는 부분 선택을 할 수 있다.

/*[<시작 비트>+:폭] -> 시작비트부터 부분 선택 증가
  [<시작 비트>-:폭] -> 시작비트부터 부분 선택 감소*/

// 부분 선택의 시작 비트는 다양하다.
// 그러나 폭은 일정해야 한다.

reg [255:0] data1; // 리틀-에디언(Little endian) 표기법
reg [0:255] data2; // 빅-에디언(Big endian) 표기법
reg [7:0] byte;

// 가변 부분을 선택 사용, 각각은 부분들을 선택할 수 있다
byte = data1[31-:8]; // starting bit = 31, width = 8 => data[31:24]
byte = data1[24+:8]; // starting bit = 24, width = 8 => data[31:24]
byte = data2[31-:8]; // starting bit = 31, width = 8 => data[24:31]
byte = data2[24+:8]; // starting bit = 24, width = 8 => data[24:31]

// 시작 비트는 변할 수 있다. 폭은 상수값을 가진다.
// 그러므로, 루프문을 이용하여 벡터의 모든 바이트들을
// 선택하기 위하여 가변 부분 선택을 할 수 있다.
for (j = 0; j<=31; j=j+1)
    byte = data1[(j*8)+:8]; // 순서는 [7:0], [15:8], ... , [255:248]

// 벡터의 부분을 초기화할 수 있다.
data1[(byteNum*8)+:8] = 8'b0; // 만약 byteNum = 1, 8비트 [15:8]를 클리어.

//


